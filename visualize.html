<!DOCTYPE html>

<svg></svg>
<script type="text/javascript" src="graph_data.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

n = dataNodes.length

// create a reverse graph and count degrees.
// each vertex has 4 additional properties: bool shown, bool is_expanded, int internal_indegree, int number_of_expanded_ins, int trackStackPosition
for(let i = 0; i < n; ++i){
  dataNodes[i].shown = false;
  dataNodes[i].is_expanded = false;
  dataNodes[i].internal_indegree = 0;
  dataNodes[i].number_of_expanded_ins = 0;
}

reverseNeighbours = [];
for(let i = 0; i < n; ++i) reverseNeighbours.push([]);
for(let u = 0; u < n; ++u){
  for(let v of neighbours[u]){
    // create reverse graph
    reverseNeighbours[v].push(u);

    // count indegree
    dataNodes[v].internal_indegree+=1;
  }
}

// show a node if it is root
for(let u = 0;u < n; ++u) if(dataNodes[u].internal_indegree == 0) 
  dataNodes[u].shown = true;

// transform the graph into a set of edges for d3.js
// each link has 1 additional property: bool shown
dataLinks = [];
linksPointers = [];
for(let i = 0; i < n; ++i) linksPointers.push([]);
for(let u = 0; u < n; ++u){
  for(let v of neighbours[u]){
    dataLinks.push({source: dataNodes[u], target: dataNodes[v]});

    // add the pointer to the last one
    linksPointers[u].push(dataLinks[dataLinks.length - 1]);
  }
}


// GRAPHICS

// are we currently tracking a node
trackingNode = false; 

// list of all previously and currently tracked node, w/ the following properties:
// - if an elements has trackStackPosition defined, then it is shown
// - if the list is nonempty the last node's trackStackPosition is guaranteed to be defined 
// we update the tracked nodes accordingly to the following guidelines:
// - if the node is clicked:
//    if the node is already in the list, all that come before it are deleted, making it the last
//    else the node is added as the last one
// - if the node is collapsed
//    then all descendants cease to be shown and have their trackStackPosition reset to null
//    the collapsed node is also removed from the list
//    the last node with a defined trackStackPosition is now being tracked (or the list becomes empty)
trackedNodes = []; 

function removeTracking(u){
  // while the list is nonempty and the last one does not have trackStackPosition defined, pop it
  while(trackedNodes.length > 0 && dataNodes[trackedNodes[trackedNodes.length - 1]].trackStackPosition == null)
  {
    trackedNodes.pop();

  }
  if(trackedNodes.length == 0) 
    trackingNode = false;
}

function addTracking(u){
  // TODO remove after testing
  if(!dataNodes[u].shown)
    throw new Error("The node in pending to be tracked should be shown.")
  
  if(dataNodes[u].trackStackPosition == null){
    trackedNodes.push(u)
    dataNodes[u].trackStackPosition = trackedNodes.length-1;
  }
  else{
    while(trackedNodes.length > dataNodes[u].trackStackPosition+1)
      trackedNodes.pop()
  }
  trackingNode = true;
}

function getTrackedNode(){
  // TODO remove after testing
  if(trackedNodes.length == 0) throw new Error("TrackingNode is true, but there are no nodes to track i. e. trackedNodes list is empty.")
  return dataNodes[trackedNodes[trackedNodes.length - 1]];
}

function unshow(u){
  if(dataNodes[u].number_of_expanded_ins == 0 && dataNodes[u].internal_indegree > 0){
    if(!dataNodes[u].shown) return;
    dataNodes[u].shown = false;
    
    dataNodes[u].trackStackPosition = null;

    collapse(u);
  }
}

function collapse(u){
  if(!dataNodes[u].is_expanded || neighbours[u].length == 0) return;
  dataNodes[u].is_expanded = false;
  
  dataNodes[u].trackStackPosition = null;

  // TODO pazi vrstni red
  for(let e = 0; e < neighbours[u].length; ++e){
    let v = neighbours[u][e];
    // update number_of_expanded_ins
    dataNodes[v].number_of_expanded_ins--;
  }
  for(let e = 0; e < neighbours[u].length; ++e){
    let v = neighbours[u][e];
    // potentially unshow neighbours
    unshow(v);
  }
}

function expand(u){
  // check if it is already expanded
  if(dataNodes[u].is_expanded || neighbours[u].length == 0) return;
  dataNodes[u].is_expanded = true;

  for(let e = 0; e < neighbours[u].length; ++e){
    // show neighbour and update number_of_expanded_ins
    let v = neighbours[u][e];

    dataNodes[v].shown = true;
    dataNodes[v].number_of_expanded_ins+=1;
  }
}

colourPalette = 
{
  "green":"#1b9e77",
  "orange":"#d95f02",
  "blue":"#7570b3",
  "pink":"#e7298a",
  "green":"#66a61e",
  "yellow":"#e6ab02",
  "brown":"#a6761d",
  "black":"#666666",
  "red":"#d62728"
}

function getColourFromPalette(colour){
  if(colourPalette[colour] == null) 
    return colourPalette.black
  else 
    return colourPalette[colour]
}

function setNodeColor(d){
  if(d.is_expanded || neighbours[d.id].length == 0){
    return d3.color(getColourFromPalette(d.co)).darker(1)
  }
  else return d3.color(getColourFromPalette(d.co))
}

// svg dimensions
const width = window.innerWidth*0.99;
const height = window.innerHeight*0.97;

// create a canvas
const svg = d3
  .select("svg")
    .attr("id", "canvas")
    .attr("viewBox", [-width/2, -height/2, width, height])
    .attr("width", width)
    .attr("height", height)
    .attr("style", "font: 12px sans-serif;")
//    .call(d3.zoom().on("zoom", function (d) {
//      if(!trackingNode){ // if we are not tracking a node, follow the event i. e. mouse
//        svg.attr("transform", d.transform);
//      }
//    }))
  .append("g");


// create one arrow that will be pasted at the end of each connection.
svg
  .append('defs')
  .append('marker')
  .attr('id', 'arrow')
  .attr("viewBox", "0 -5 10 10")
    .attr("refX", 30)
    .attr("refY", -0.5)
    .attr("markerWidth", 10)
    .attr("markerHeight", 10)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5")
// add a graphic that contains all links
const allLinks = svg.append("g")
  .attr("class", "allLinks");

const nodeRadius = 7;
const tooltipLineDistance = 1.5; // distance between lines in the tooltip in units em
const tooltipInitialOffset = 2; // initial offset between the tooltip and node name in units em

const timeHoveredToTooltip = 1000; // milisecond for which a user must hover over the node to display the node's tooltip

const tooltipBoxDistFromNodeX = 7; // the distance from the node and the tooltip box in pixels in the x direction
const tooltipBoxDistFromNodeY = 9; // the distance from the node and the tooltip box in pixels in the x direction
const tooltipWidth = 250; // tooltip width in pixels

// add a graphic that contains all nodes
const allNodes = svg.append("g")
  .attr("class", "allNodes");

nodeProperties = {
  name: "name",
  betweenness: "betweenness",
  current_flow_betweenness : "current flow betweenness",
  degree : "degree",
  in_degree : "indegree",
  out_degree : "outdegree",
  n_cycles : "n-cycles",
  eigen_centrality : "eigen-centrality",
  label : "label",
  pagerank: "pagerank",
};

// update the simulation
var simulation = d3.forceSimulation()
      .force("link", d3.forceLink()
        .id(d => d.id)
      )
      .force("charge", d3.forceManyBody()
        .strength(-1000)
      )
      .force("x", d3.forceX())
      .force("y", d3.forceY());

// create dataLinks and add an arrow to each link
function update(){
  links = d3.select(".allLinks")
    .selectAll("path")
    .data(d3.filter(dataLinks, d => d.source.shown && d.target.shown), d =>  d.source.id.toString() + "->" + d.target.id.toString())
    .join(
      function(enter) {
        curLink = enter
          .append("path")
          .attr("stroke", "#999")
          .attr("stroke-opacity", 0.6)
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrow)');
        return curLink;
      },
      function(update) {
        return update;
      },
      function(exit) {
        // remove the link on exit
        return exit.remove();
      }
    )

  nodes = d3.select(".allNodes")
    .selectAll(".node")
    .data(d3.filter(dataNodes, d => d.shown), d => d.id) // filter those that are marked as shown, d=>d function means that nodes are identified by their data
    .join(
      function(enter) {
        // create graphic containers for one node to which we will add a circle and text (label)
        curNode = enter
          .append("g")
            .attr("class", "node");
        
        // create circles around nodes
        curNode 
          .append("circle")
            .attr("class", "nodecircle")
            .attr("stroke", "black")
            .attr("stroke-width", 1.5)
            .attr("fill", d => setNodeColor(d))
            .attr("r", nodeRadius)

        // add label to nodes
        curNode
          .append("text")
            .attr("x", 10)
            .attr("y", "0.31em")
            .text(d => d.name)
          // add a white outline to text (label)
          // NOTE: in svg this will add two <text> badges to a node <g>, one for text and one for outline
          .clone(true).lower()
            .attr("fill", "none")
            .attr("stroke", "white")
            .attr("stroke-width", 3);
        
        tooltip = curNode
          .append("svg")
            .attr("class", "tooltip")
            .attr("display", "none")
              .append("g");
        
        tooltipHeight = tooltipLineDistance * (Object.keys(nodeProperties).length + 1); // in ems
        tooltip.append("rect")
          .attr("class", "tooltipBox")
          .attr("x", tooltipBoxDistFromNodeX.toString() + "px")
          .attr("y", (tooltipInitialOffset*2).toString())
          .attr("height", tooltipHeight.toString() + "em")
          .attr("width", tooltipWidth)
          .style("stroke", "black")
          .style("stroke-width", 1)
          .style("rx", "3px")
          .attr("fill", "black");
            
        // add a tooltip showing additional information about the node on hover
        let cnt = 0;
        for (const [key, value] of Object.entries(nodeProperties)) {
          positionY = tooltipLineDistance * cnt + tooltipInitialOffset;

          tooltip.append("text")
            .attr("fill", "white")
            .attr("x", 20)
            .attr("y", positionY.toString() + "em")
            .attr("font-weight", 600)
            .text(d => value + ": ")
            .append("tspan")
            .attr("font-weight", 300)
            .text(d => d[key])
            ++cnt;
        }
        return curNode;
      },
      function(update) {
        update.select(".nodecircle")
          .attr("fill", d => setNodeColor(d))
        return update;
      },
      function(exit) {
        // remove the node on exit
        return exit.remove();
      }
    )
    // TODO, drag starts before click
    
    //.call(d3.drag() // set drag behaviour
        //.on("start", dragstarted)
        //.on("drag", dragged)
        //.on("end", dragended))
        .on("click", clicked);
        //.on("mouseover", mousedover)
        //.on("mouseout", mousedout);
  
  //// reheat the simulation when drag starts, and fix the subject position
  //function dragstarted(event) {
  //  if (!event.active) simulation.alphaTarget(0.3).restart();
  //  event.subject.x = event.subject.x;
  //  event.subject.y = event.subject.y;
  //}
  //// update the subject (dragged node) position during drag
  //function dragged(event) {
  //  event.subject.x = event.x;
  //  event.subject.y = event.y;
  //}
  //// restore the target alpha so the simulation cools after dragging ends
  //// unfix the subject position now that itâ€™s no longer being dragged
  //function dragended(event) {
  //  if (!event.active) simulation.alphaTarget(0);
  //  event.subject.x = null;
  //  event.subject.y = null;
  //}
  function clicked(event){
    node = d3.select(this).data()[0]; // select the corresponding datum

    // on click collapse the nodes, or expand it i. e. show its most immediate neighbours (and their whole SCCs)
    // if node is clicked then:
    
    if(node.is_expanded){
      collapse(node.id);
      removeTracking(node.id);//  if it is collapsed, stop tracking it, return to previously tracked node
    }
    else {
      expand(node.id);
      addTracking(node.id) //  if it is expanded, start tracking it
    }
    
    update();
  }
  //function mousedover(event){
  //  d3.select(this)
  //    .raise() // make sure that the tooltip gets displayed over the nodes
  //    .select(".tooltip")
  //      .raise()
  //      .transition()
  //      .delay(700)
  //      .attr("display", "inline")
  //
  //  d3.select(this)
  //    .select(".tooltipBox")
  //      .transition()
  //      .attrTween("width", () => (t) => t*tooltipWidth)
  //      .delay(700)
  //      .attr("display", "inline");
  //}
  //function mousedout(event){
  //  nodeG = d3.select(this)
  //    .select(".tooltip")
  //      .transition()
  //        .delay(0)
  //      .attr("display", "none");
  //}

  simulation.nodes(nodes.data());
  simulation.force("link").links(links.data());

  // on simulation tick (refresh graphics) update nodes and edges
  simulation.on("tick", () => {
    console.log("tick");
    links
      .attr('d', d => d3.line()([[d.source.x, d.source.y], [d.target.x, d.target.y]]));
    nodes
      .attr("transform", d => `translate(${d.x},${d.y})`);
    //if(trackingNode){
    //  let currentTrackedNode = getTrackedNode();
    //  let translation = d3.zoomIdentity;
    //  translation.x = -currentTrackedNode.x;
    //  translation.y = -currentTrackedNode.y;
    //  svg.attr("transform", translation);
    //}
  });
}

update();
</script>