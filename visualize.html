<!DOCTYPE html>
<meta charset="UTF-8" />
<style>
  .node circle {
    stroke: steelblue;
    stroke-width: 3px;
  }

  .node text {
    font: 12px sans-serif;
  }

  .link {
    fill: none;
    stroke: #ccc;
    stroke-width: 2px;
  }
</style>

<body>
  <!-- load the d3.js library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script type="text/javascript" src="scripts/constants.js"></script>
  <script type="text/javascript" src="scripts/graph_data.js"></script>
  <script type="text/javascript" src="scripts/setUpData.js"></script>
  <script type="text/javascript" src="scripts/setupSvg.js"></script>
  <script type="text/javascript" src="scripts/expansion.js"></script>
  <script type="text/javascript" src="scripts/buchheimetal.js"></script>
  <script type="text/javascript">
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function getColourFromPalette(colour) {
      if (colourPalette[colour] == null) {
        return colourPalette.black
      } else {
        return colourPalette[colour]
      }
    }

    function setNodeColor(d) {
      if (d.expanded || neighbours[d.id].length == 0) {
        return d3.color(getColourFromPalette(d.co)).darker(1)
      } else {
        return d3.color(getColourFromPalette(d.co))
      }
    }
    const allLinks = svg.append('g').attr('class', 'allLinks')
    const allNodes = svg.append('g').attr('class', 'allNodes')

    function update() {
      // nodes
      var node = svg
        .select('.allNodes')
        .selectAll('.node')
        .data(
          d3.filter(dataNodes, d => d.shown),
          d => d.id
        )
        .join(
          function (enter) {
            // create graphic containers for one node to which we will add a circle and text (label)

            curNode = enter
              .append('g')
              .attr('class', 'node')
              .attr('transform', function (d) {
                return 'translate(' + d.y0 + ',' + d.x0 + ')'
              })

            curNode
              .transition()
              .duration(duration)
              .attr('class', 'node')
              .attr('transform', function (d) {
                return 'translate(' + d.y + ',' + d.x + ')'
              })

            // create circles around nodes
            curNode
              .append('circle')
              .attr('stroke-width', 1.5)
              .attr('fill', d => setNodeColor(d))
              .attr('r', nodeRadius)

            // add label to nodes
            curNode
              .append('text')
              .attr('x', 10)
              .attr('y', '0.31em')
              .text(d => d.name)
              // add a white outline to text (label)
              // NOTE: in svg this will add two <text> badges to a node <g>, one for text and one for outline
              .clone(true)
              .lower()
              .attr('fill', 'none')
              .attr('stroke', 'white')
              .attr('stroke-width', 3)

            tooltip = curNode
              .append('svg')
              .attr('class', 'tooltip')
              .attr('display', 'none')
              .append('g')

            tooltipHeight =
              0.75 *
              tooltipLineDistance *
              (Object.keys(nodeProperties).length + 1) // in ems
            tooltip
              .append('rect')
              .attr('class', 'tooltipBox')
              .attr('x', tooltipBoxDistFromNodeX.toString() + 'px')
              .attr('y', (tooltipInitialOffset * 2).toString())
              .attr('height', tooltipHeight.toString() + 'em')
              .attr('width', tooltipWidth)
              .style('stroke', 'black')
              .style('stroke-width', 1)
              .style('rx', '3px')
              .attr('fill', 'black')

            // add a tooltip showing additional information about the node on hover
            let cnt = 0
            for (const [key, value] of Object.entries(nodeProperties)) {
              positionY = tooltipLineDistance * cnt + tooltipInitialOffset

              tooltip
                .append('text')
                .attr('fill', 'white')
                .attr('x', 20)
                .attr('y', positionY.toString() + 'em')
                .attr('font-weight', 600)
                .text(d => value + ': ')
                .append('tspan')
                .attr('font-weight', 300)
                .text(d => d[key])
              ++cnt
            }
            return curNode
          },
          function (update) {
            update.selectAll('circle').attr('fill', d => setNodeColor(d));
            return update
              .transition()
              .duration(duration)
              .attr('transform', function (d) {
                return 'translate(' + d.y + ',' + d.x + ')'
              })
              
          },
          function (exit) {
            // remove the node on exit
            return exit
              .transition()
              .duration(duration)
              .attr('transform', function (d) {
                return 'translate(' + d.y + ',' + d.x + ')'
              })
              .remove()
          }
        )
        .on('click', clicked)
        .on('mouseover', mousedover)
        .on('mouseout', mousedout)

      function mousedover(event) {
        d3.select(this)
          .raise() // make sure that the tooltip gets displayed over the nodes
          .select('.tooltip')
          .raise()
          .transition()
          .delay(duration)
          .attr('display', 'inline')

        d3.select(this)
          .select('.tooltipBox')
          .transition()
          .attrTween('width', () => t => t * tooltipWidth)
          .delay(duration)
          .attr('display', 'inline')
      }
      function mousedout(event) {
        d3
          .select(this)
          .select('.tooltip')
          .transition()
          .delay(0)
          .attr('display', 'none')
      }

      function clicked(event) {
        let u = d3.select(this).data()[0].id // select the corresponding datum

        if (dataNodes[u].expanded) {
          unshowed = []
          collapse(u, u)
          arrangeTree()
          postProcess()

          // unshowed nodes go into the clicked
          for (let v of unshowed) {
            dataNodes[v].x0 = dataNodes[v].x
            dataNodes[v].y0 = dataNodes[v].y

            dataNodes[v].x = dataNodes[u].x
            dataNodes[v].y = dataNodes[u].y
          }

          update()
        } else {
          expand(u)
          arrangeTree()
          postProcess()
          update()
        }

        /*//TODO what is happening here
      let currenttransform = getFloatsFromString(svg.attr("transform"));
      let ck = currenttransform[2];
      if(ck == null) ck = 1;

      let translation = d3.zoomIdentity;
      translation.x = -dataNodes[u].y;
      translation.y = -dataNodes[u].x;
      translation.k = ck;
      
      svg
        .transition().duration(translateZoomDuration)
        .attr("transform", translation);*/
      }

      // links

      function diagonal(s, d, offset) {
        if (s.y == d.y) {
          path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2 + offset} ${s.x},
              ${(s.y + d.y) / 2 + offset} ${d.x},
              ${d.y} ${d.x}`
          return path
        } else {
          path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`
          return path
        }
      }
      links = d3
        .select('.allLinks')
        .selectAll('path')
        .data(
          d3.filter(
            dataLinks,
            d => d.source.shown && d.source.expanded && d.target.shown
          ),
          d => d.source.id.toString() + '->' + d.target.id.toString()
        )
        .join(
          function (enter) {
            addedLink = enter
              .insert('path', 'g')
              .attr('class', 'link')
              .attr('d', function (d) {
                //TODO
                return diagonal(
                  { x: d.source.x0, y: d.source.y0 },
                  { x: d.target.x0, y: d.target.y0 },
                  d.offset
                )
              })

            addedLink
              .transition()
              .duration(duration)
              .attr('d', function (d) {
                return diagonal(
                  { x: d.source.x, y: d.source.y },
                  { x: d.target.x, y: d.target.y },
                  d.offset
                )
              })
          },
          function (update) {
            return update
              .transition()
              .duration(duration)
              .attr('d', function (d) {
                return diagonal(
                  { x: d.source.x, y: d.source.y },
                  { x: d.target.x, y: d.target.y },
                  d.offset
                )
              })
          },
          function (exit) {
            // remove the link on exit
            return exit
              .transition()
              .duration(duration)
              .attr('d', function (d) {
                //TODO
                return diagonal(
                  { x: d.source.x, y: d.source.y },
                  { x: d.target.x, y: d.target.y },
                  d.offset
                )
              })
              .remove()
          }
        )
    }
    arrangeTree()
    update()
  </script>
</body>
